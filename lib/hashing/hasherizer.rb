require "optioning"

module Hashing
  class Serialization
    attr_reader :ivars

    def initialize(host_class, ivars = nil)
      @host_class = host_class
      @ivars = ivars
    end

    def to(block)
      self
    end

    def from(block)
      self
    end

    # Configures the strategy to (re)create an instance of the 'hasherized ®'
    # class based on a `Hash` instance. This strategy will be used by the
    # `.from_hash({})` method.
    #
    # This configuration is optional, if it's not called, then the strategy will
    # be just repassing the `Hash` to the initializer.
    #
    # @param strategy [#call]
    # @return void
    def loading(block)
      @loading = block
      self
    end

    def loader
      @loading || ->(hash) { @host_class.new hash }
    end
  end

  # Define the class methods that should be available in a 'hasherized ®' class
  # (a class that include `Hashing`).
  module Hasherizer
    # Configures which instance variables will be used to compose the `Hash`
    # generated by `#to_h`
    #
    # @api
    # @param ivars [Array<Symbol>]
    def hasherize(*ivars)
      @__serialization = Serialization.new self, ivars
    end

    # those methods are private but part of the class api (macros).
    # #TODO: there is a way to document the 'macros' for a class in YARD?
    private :hasherize

    # Receives a `Hash` and uses the strategy configured by `.loading` to
    # (re)create an instance of the 'hasherized ®' class.
    #
    # @param pairs [Hash] in a valid form defined by `.hasherize`
    # @return new object
    def from_hash(pairs)
      unrecognized_keys = pairs.keys - Array(__serialization.ivars)
      if unrecognized_keys.count > 0
        raise Hashing::UnconfiguredIvar.new unrecognized_keys, self
      end
      __serialization.loader.call pairs
    end

    private
    def __serialization
      @__serialization ||= Serialization.new self
    end
  end
end
