require "hashing/version"

module Hashing
  # Inject the public api into the client class.
  #
  # @since 0.0.1
  #
  # @example including Hashing
  #   require 'hashing'
  #
  #   class File
  #     include Hashing
  #     hasherize :path, :commit
  #
  #     def initialize(path, commit)
  #       @path, @commit = path, commit
  #     end
  #   end
  #
  # When `Hashing` is included, the host class will gain the `.from_hash({})`
  # method and the `#to_h` instance method.
  # Another method that will be added is the private class method `.hasherize`
  # will be added so you can indicate what ivars do you want in your sarialized
  # objects.
  def self.included(client_class)
    client_class.extend Hasherizer
  end

  # The `Hash` returned by `#to_h` will be formed by keys based on the ivars
  # names passed to `hasherize` method.
  #
  # @example File hahserized (which include `Hashing`)
  #
  #   file = File.new 'README.md', 'cfe9aacbc02528b'
  #   file.to_h
  #   # => { path: 'README.md', commit: 'cfe9aacbc02528b' }
  def to_h
    final_hash = {}
    self.class.ivars.each do |ivar|
      final_hash[ivar.to_sym] = instance_variable_get "@#{ivar}"
    end
    final_hash
  end

  # Define the class methods that should be available in a 'hasherized ®' class
  # (a class that include `Hashing`).
  module Hasherizer
    def ivars
      @ivars ||= []
    end

    # Configures which instance variables will be used to compose the `Hash`
    # generated by `#to_h`
    #
    # @api
    # @param ivars [*arguments]
    def hasherize(*ivars)
      @ivars = ivars
    end

    # Configures the strategy to (re)create an instance of the 'hasherized ®'
    # class based on a `Hash` instance. This strategy will be used by the
    # `.from_hash({})` method.
    #
    # This configuration is optional, if it's not called, then the strategy will
    # be just repassing the `Hash` to the initializer.
    #
    # @param strategy [#call]
    # @return void
    def loading(strategy)
      @strategy = strategy
    end

    # Provides the default strategy for recreate objects from hashes (which is
    # just call .new passing the `Hash` as is.
    def strategy
      @strategy || ->(h) { new h }
    end
    private :hasherize, :loading, :strategy

    # Receives a `Hash` and uses the strategy configured by `.loading` to
    # (re)create an instance of the 'hasherized ®' class.
    #
    # @param pairs [Hash] in a valid form defined by `.hasherize`
    # @return new object
    def from_hash(pairs)
      strategy.call pairs
    end
  end
end
