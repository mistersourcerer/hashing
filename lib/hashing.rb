require 'hashing/version'
require 'hashing/ivar'
require 'hasherize'

module Hashing
  # Inform the user about an attempt to create an instance, using a `Hash` with
  # keys that does not correspond to the mape made using `.hasherize`
  class UnconfiguredIvar < StandardError
    def initialize(ivar_name, class_name)
      super "The Hash has a :#{ivar_name} key, "+
        "but no @#{ivar_name} was configured in #{class_name}"
    end
  end

  # Inject the public api into the client class.
  #
  # @since 0.0.1
  #
  # @example including Hashing
  #   require 'hashing'
  #
  #   class File
  #     include Hashing
  #     hasherize :path, :commit
  #
  #     def initialize(path, commit)
  #       @path, @commit = path, commit
  #     end
  #   end
  #
  # When `Hashing` is included, the host class will gain the `.from_hash({})`
  # method and the `#to_h` instance method.
  # Another method that will be added is the private class method `.hasherize`
  # will be added so you can indicate what ivars do you want in your sarialized
  # objects.
  def self.included(client_class)
    client_class.extend Hasherizer
  end

  def meta_data(name, value)
    @_hashing_meta_data ||= { __hashing__: { types: {} } }
    @_hashing_meta_data[:__hashing__][:types][name] = value
    @_hashing_meta_data
  end

  #
  # The `Hash` returned by `#to_h` will be formed by keys based on the ivars
  # names passed to `hasherize` method.
  #
  # @example File hahserized (which include `Hashing`)
  #
  #   file = File.new 'README.md', 'cfe9aacbc02528b'
  #   file.to_h
  #   # => { path: 'README.md', commit: 'cfe9aacbc02528b' }
  def to_h
    hash_pairs = self.class.ivars.map { |ivar|
      value = instance_variable_get "@#{ivar}"
      if value.respond_to? :map
        meta_data ivar.to_sym, value.first.class
      end
      [ivar.to_sym, ivar.to_h(value)]
    }
    Hash[hash_pairs].merge(@_hashing_meta_data || {})
  end

  # Define the class methods that should be available in a 'hasherized ®' class
  # (a class that include `Hashing`).
  module Hasherizer
    # Configures which instance variables will be used to compose the `Hash`
    # generated by `#to_h`
    #
    # @api
    # @param ivars_and_options [*arguments]
    def hasherize(*ivars_and_options)
      @ivars ||= []
      ivars = extract_ivars ivars_and_options
      to_strategy = strategy_for_key :to_hash, ivars_and_options
      from_strategy = strategy_for_key :from_hash, ivars_and_options
      @ivars += ivars.map { |ivar| Ivar.new ivar, to_strategy, from_strategy }
    end

    # Configures the strategy to (re)create an instance of the 'hasherized ®'
    # class based on a `Hash` instance. This strategy will be used by the
    # `.from_hash({})` method.
    #
    # This configuration is optional, if it's not called, then the strategy will
    # be just repassing the `Hash` to the initializer.
    #
    # @param strategy [#call]
    # @return void
    def loading(strategy)
      @strategy = strategy
    end

    # Provides the default strategy for recreate objects from hashes (which is
    # just call .new passing the `Hash` as is.
    #
    # @return the result of calling the strategy
    def strategy
      @strategy || ->(h) { new h }
    end

    # those methods are private but part of the class api (macros).
    # #TODO: there is a way to document the 'macros' for a class in YARD?
    private :hasherize, :loading, :strategy

    # provides access to the current configuration on what `ivars` should be
    # used to generate a `Hash` representation of instances of the client class.
    #
    # @return [Array] ivars that should be included in the final Hash
    def ivars
      @ivars ||= []
    end

    # Receives a `Hash` and uses the strategy configured by `.loading` to
    # (re)create an instance of the 'hasherized ®' class.
    #
    # @param pairs [Hash] in a valid form defined by `.hasherize`
    # @return new object
    def from_hash(pairs)
      metadata = pairs.delete(:__hashing__) || {}
      hash_to_load = pairs.map do |ivar_name, value|
        ivar = ivar_by_name ivar_name.to_sym
        [ivar.to_sym, ivar.from_hash(value, metadata)]
      end
      strategy.call Hash[hash_to_load]
    end

    private
    # Cleanup the arguments received by `.hasherize` so only the `ivar` names
    # are returned. This is necessarey since the `.hasherize` can receive a
    # `Hash` with strategies `:from_hash` and `:to_hash` as the last argument.
    #
    # @param ivars_and_options [Array] arguments received by `.serialize`
    # @return [Array[:Symbol]] ivar names that should be used in the `Hash` serialization
    def extract_ivars(ivars_and_options)
      ivars = ivars_and_options.dup
      if ivars.last.is_a? Hash
        ivars.pop
      end
      ivars
    end

    # Fetches the strategy to serialize or deserialize (defined by the first
    # param `strategy`) the `ivars` passed as second parameter
    #
    # @param hash_key [Symbol] (:to_hash || :from_hash) type of strategy to fetch
    # @param ivars_and_options [*args | *args, Hash]
    # @return [#call] strategy to be used
    def strategy_for_key(strategy, ivars_and_options)
      default_strategy_just_returns = ->(ivar_value) { ivar_value }
      strategies = { strategy => default_strategy_just_returns }
      strategies = ivars_and_options.last if ivars_and_options.last.is_a? Hash
      strategies[strategy]
    end

    # Search an `ivar` by it's name in the class ivars collection
    #
    # #TODO: Can be enhanced since now the ivars doesn't have a sense of
    # equality.
    #
    # @param ivar_name [Symbol] `ivar` name
    # @return [Ivar]
    def ivar_by_name(ivar_name)
      ivar = ivars.select { |ivar| ivar.to_sym == ivar_name }.first
      raise UnconfiguredIvar.new ivar_name, name unless ivar
      ivar
    end
  end
end
